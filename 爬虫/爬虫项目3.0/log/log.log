[2016-12-27 17:51:15 INFO : insert into task_result (task_id,url,content) values (1,http://cuiqingcai.com/977.html,Python爬虫入门七之正则表达式 | 静觅),(1,http://cuiqingcai.com/977.html,Python爬虫入门七之正则表达式),(1,http://cuiqingcai.com/977.html,在前面我们已经搞定了怎样获取页面的内容，不过还差一步，这么多杂乱的代码夹杂文字我们怎样把它提取出来整理呢？下面就开始介绍一个十分强大的工具，正则表达式！),(1,http://cuiqingcai.com/977.html,1.了解正则表达式),(1,http://cuiqingcai.com/977.html,正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。),(1,http://cuiqingcai.com/977.html,正则表达式是用来匹配字符串非常强大的工具，在其他编程语言中同样有正则表达式的概念，Python同样不例外，利用了正则表达式，我们想要从返回的页面内容提取出我们想要的内容就易如反掌了。),(1,http://cuiqingcai.com/977.html,正则表达式的大致匹配过程是：),(1,http://cuiqingcai.com/977.html,2.正则表达式的语法规则),(1,http://cuiqingcai.com/977.html,下面是Python中正则表达式的一些匹配规则，图片资料来自CSDN),(1,http://cuiqingcai.com/977.html,3.正则表达式相关注解),(1,http://cuiqingcai.com/977.html,正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab*”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab*?”，将找到”a”。),(1,http://cuiqingcai.com/977.html,与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。),(1,http://cuiqingcai.com/977.html,Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\\”表示。同样，匹配一个数字的”\\d”可以写成r”\d”。有了原生字符串，妈妈也不用担心是不是漏写了反斜杠，写出来的表达式也更直观勒。),(1,http://cuiqingcai.com/977.html,Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下),(1,http://cuiqingcai.com/977.html, • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同） • re.M(全拼：MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图） • re.S(全拼：DOTALL): 点任意匹配模式，改变'.'的行为 • re.L(全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 • re.U(全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。),(1,http://cuiqingcai.com/977.html,详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。),(1,http://cuiqingcai.com/977.html,__author__ = 'CQC'# -*- coding: utf-8 -*-#导入re模块import re# 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”pattern = re.compile(r'hello')# 使用re.match匹配文本，获得匹配结果，无法匹配时将返回Noneresult1 = re.match(pattern,'hello')result2 = re.match(pattern,'helloo CQC!')result3 = re.match(pattern,'helo CQC!')result4 = re.match(pattern,'hello CQC!')#如果1匹配成功if result1:    # 使用Match获得分组信息    print result1.group()else:    print '1匹配失败！'#如果2匹配成功if result2:    # 使用Match获得分组信息    print result2.group()else:    print '2匹配失败！'#如果3匹配成功if result3:    # 使用Match获得分组信息    print result3.group()else:    print '3匹配失败！'#如果4匹配成功if result4:    # 使用Match获得分组信息    print result4.group()else:    print '4匹配失败！'),(1,http://cuiqingcai.com/977.html,# 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”),(1,http://cuiqingcai.com/977.html,1.第一个匹配，pattern正则表达式为’hello’，我们匹配的目标字符串string也为hello，从头至尾完全匹配，匹配成功。),(1,http://cuiqingcai.com/977.html,3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。),(1,http://cuiqingcai.com/977.html,4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。),(1,http://cuiqingcai.com/977.html,#导入re模块import re# 将正则表达式编译成Pattern对象pattern = re.compile(r'world')# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None# 这个例子中使用match()无法成功匹配match = re.search(pattern,'hello world!')if match:    # 使用Match获得分组信息    print match.group()### 输出 #### world),(1,http://cuiqingcai.com/977.html,# 将正则表达式编译成Pattern对象),]
